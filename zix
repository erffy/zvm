#!/usr/bin/env bash

# SPDX-License-Identifier: GPL-3.0-only
#
# Copyright (c) 2026 erffy
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program. If not, see <https://gnu.org/licenses>.

set -euo pipefail

# CONFIG
ZIG_HOME="${ZIG_HOME:-$HOME/.zig}"
VERSIONS_DIR="$ZIG_HOME/versions"
CACHE_DIR="$ZIG_HOME/cache"
ACTIVE_LINK="$ZIG_HOME/active"
BIN_DIR="${ZIX_BIN_DIR:-$HOME/.local/bin}"
ZIG_SYMLINK="$BIN_DIR/zig"
SELF_PATH="${BASH_SOURCE[0]}"

INDEX_URL="https://ziglang.org/download/index.json"
MIRROR_LIST_URL="https://ziglang.org/download/community-mirrors.txt"

CACHE_TTL=$((6 * 3600))
INDEX_CACHE="$CACHE_DIR/index.json"
INDEX_TS="$CACHE_DIR/index.timestamp"
MIRROR_CACHE="$CACHE_DIR/mirrors.txt"
MIRROR_TS="$CACHE_DIR/mirrors.timestamp"

OS="$(uname -s | tr '[:upper:]' '[:lower:]')"
ARCH="$(uname -m)"

case "$ARCH" in
  x86_64) ARCH="x86_64" ;;
  aarch64|arm64) ARCH="aarch64" ;;
  armv7l|armv7) ARCH="arm" ;;
  i686|i386) ARCH="x86" ;;
  riscv64) ARCH="riscv64" ;;
  powerpc64le|ppc64le) ARCH="powerpc64le" ;;
  powerpc64|ppc64) ARCH="powerpc64" ;;
  s390x) ARCH="s390x" ;;
  loongarch64) ARCH="loongarch64" ;;
  *) echo "zix: unsupported architecture: $ARCH" >&2; exit 1 ;;
esac

case "$OS" in
  linux) OS="linux" ;;
  darwin) OS="macos" ;;
  freebsd) OS="freebsd" ;;
  netbsd) OS="netbsd" ;;
  mingw*|msys*|cygwin*) OS="windows" ;;
  *) echo "zix: unsupported OS: $OS" >&2; exit 1 ;;
esac

# Platform key format used by Zig: ARCH-OS (e.g., x86_64-linux)
PLATFORM="$ARCH-$OS"

mkdir -p "$VERSIONS_DIR" "$CACHE_DIR" "$BIN_DIR"

# HELPERS
# Colors
if [[ -t 1 ]]; then
  RED=$(printf '\033[31m')
  GREEN=$(printf '\033[32m')
  YELLOW=$(printf '\033[33m')
  BLUE=$(printf '\033[34m')
  BOLD=$(printf '\033[1m')
  RESET=$(printf '\033[0m')
else
  RED=""
  GREEN=""
  YELLOW=""
  BLUE=""
  BOLD=""
  RESET=""
fi

die() { echo "${RED}error:${RESET} $*" >&2; exit 1; }
warn() { echo "${YELLOW}warning:${RESET} $*" >&2; }
info() { echo "${BLUE}info:${RESET} $*"; }
success() { echo "${GREEN}success:${RESET} $*"; }
now() { date +%s; }

require() {
  command -v "$1" >/dev/null || die "missing required dependency: $1 (install it with your package manager)"
}

# Unified fetch function
# Usage: fetch_url <url> <output_file> [timeout_sec]
fetch_url() {
  local url="$1"
  local output="$2"
  local timeout="${3:-30}"
  local dir
  dir="$(dirname "$output")"
  local file
  file="$(basename "$output")"
  
  mkdir -p "$dir"

  case "$DOWNLOADER" in
    aria2c)
      aria2c --console-log-level=warn --summary-interval=0 \
        -x 16 -s 16 -k 1M \
        --max-tries=3 --retry-wait=2 \
        --connect-timeout=10 --timeout="$timeout" \
        --allow-overwrite=true \
        --auto-file-renaming=false \
        -d "$dir" -o "$file" \
        "$url"
      ;;
    curl)
      curl -fL --progress-bar \
        --connect-timeout 10 --max-time "$((timeout * 2))" \
        --retry 2 --retry-delay 2 \
        "$url" -o "$output"
      ;;
    wget)
      wget --show-progress -q \
        --timeout="$timeout" --tries=3 --waitretry=2 \
        -O "$output" "$url"
      ;;
  esac
}



# Check for download tools (at least one required)
detect_downloader() {
  # Allow user to force a specific downloader via environment variable
  if [[ -n "${ZIX_DOWNLOADER:-}" ]]; then
    case "$ZIX_DOWNLOADER" in
      aria2c|curl|wget)
        if command -v "$ZIX_DOWNLOADER" >/dev/null 2>&1; then
          echo "$ZIX_DOWNLOADER"
          return 0
        else
          warn "ZIX_DOWNLOADER set to '$ZIX_DOWNLOADER' but not found, falling back to auto-detect"
        fi
        ;;
      *)
        warn "invalid ZIX_DOWNLOADER='$ZIX_DOWNLOADER', falling back to auto-detect"
        ;;
    esac
  fi
  
  # Auto-detect based on priority: aria2c (fastest) > curl (common) > wget (fallback)
  local available=()
  
  for tool in aria2c curl wget; do
    if command -v "$tool" >/dev/null 2>&1; then
      available+=("$tool")
    fi
  done
  
  if [[ ${#available[@]} -eq 0 ]]; then
    die "no download tool found. Install one of: aria2 (recommended), curl, or wget"
  fi
  
  # Return the best available option
  echo "${available[0]}"
}

DOWNLOADER=$(detect_downloader)

download_file() {
  local url="$1"
  local output="$2"
  local retries=3
  local attempt=1
  
  while (( attempt <= retries )); do
    if (( attempt > 1 )); then
      warn "download failed, retrying ($attempt/$retries)..."
      sleep 2
    fi
    
    if fetch_url "$url" "$output" 30; then
      return 0
    fi
    
    ((attempt++))
  done
  
  return 1
}

require jq
require sha256sum
require tar

cache_valid() {
  [[ -f "$1" && -f "$2" ]] && (( $(now) - $(cat "$2" 2>/dev/null || echo 0) < CACHE_TTL ))
}

# METADATA
zig_meta() {
  if cache_valid "$INDEX_CACHE" "$INDEX_TS"; then
    cat "$INDEX_CACHE"
  else
    info "fetching Zig index..."
    local tmp="$INDEX_CACHE.tmp"
    if fetch_url "$INDEX_URL" "$tmp" 30; then
      mv "$tmp" "$INDEX_CACHE"
      now > "$INDEX_TS"
      cat "$INDEX_CACHE"
    else
      rm -f "$tmp"
      [[ -f "$INDEX_CACHE" ]] && { warn "using stale cache"; cat "$INDEX_CACHE"; return; }
      die "failed to fetch index and no cache available"
    fi
  fi
}

zig_field() {
  local version="$1" field="$2"
  zig_meta | jq -r ".\"$version\".\"$PLATFORM\".$field // empty" 2>/dev/null
}

# MIRRORS
fetch_mirrors() {
  if cache_valid "$MIRROR_CACHE" "$MIRROR_TS"; then
    cat "$MIRROR_CACHE"
    return
  fi

  info "fetching mirror list..."
  local tmp="$MIRROR_CACHE.tmp"
  local fetched=false
  
  if fetch_url "$MIRROR_LIST_URL" "$tmp" 10; then
    fetched=true
  fi
  
  if [[ "$fetched" == "true" ]] && sed 's/#.*//' "$tmp" | grep -E '^https?://' > "$MIRROR_CACHE"; then
    rm -f "$tmp"
    now > "$MIRROR_TS"
    cat "$MIRROR_CACHE"
  else
    rm -f "$tmp"
    [[ -f "$MIRROR_CACHE" ]] && { warn "using cached mirrors"; cat "$MIRROR_CACHE"; return; }
    echo "https://ziglang.org/download"
  fi
}

pick_mirror() {
  local best="" best_time=99999

  info "testing mirrors..."
  while IFS= read -r m; do
    [[ -z "$m" ]] && continue
    local t
    # Use appropriate tool for speed test
    case "$DOWNLOADER" in
      aria2c|curl)
        t=$(curl -o /dev/null -sS -w '%{time_total}' --max-time 3 "$m" 2>/dev/null || echo "99.999")
        ;;
      wget)
        # wget doesn't have a direct equivalent, use curl if available for testing
        if command -v curl >/dev/null 2>&1; then
          t=$(curl -o /dev/null -sS -w '%{time_total}' --max-time 3 "$m" 2>/dev/null || echo "99.999")
        else
          t="1.0"  # Default if can't test
        fi
        ;;
    esac
    
    # Convert decimal to integer milliseconds using awk
    local t_ms
    t_ms=$(echo "$t" | awk '{printf "%.0f", $1 * 1000}')
    [[ -z "$t_ms" || "$t_ms" == "0" ]] && t_ms=99999
    if (( t_ms < best_time )); then
      best="$m"
      best_time="$t_ms"
    fi
  done < <(fetch_mirrors)

  [[ -z "$best" ]] && best="https://ziglang.org/download"
  local display_time=$(echo "$best_time" | awk '{printf "%.2f", $1 / 1000}')
  info "selected mirror: $best (${display_time}s)"
  echo "$best"
}

# CORE COMMANDS
install() {
  local version="$1"
  [[ -z "$version" ]] && die "version required (e.g., 'zix install 0.11.0' or 'zix install master')"

  local dir="$VERSIONS_DIR/$version"
  
  # Special handling for master: check if update is needed
  if [[ "$version" == "master" && -d "$dir" ]]; then
    info "master already installed, checking for updates..."
    
    # Get remote master version
    local remote_version local_version remote_build local_build
    remote_version="$(zig_meta | jq -r '.master.version // empty' 2>/dev/null)"
    local_version="$("$dir/zig" version 2>/dev/null || echo "unknown")"
    
    if [[ -z "$remote_version" ]]; then
      warn "failed to fetch remote master version, skipping update check"
      info "using existing master installation"
      return 0
    fi
    
    info "remote master: $remote_version"
    info "local master:  $local_version"
    
    # Extract build numbers (e.g., 2048 from 0.16.0-dev.2048+c475ffcd)
    remote_build=$(echo "$remote_version" | grep -oP 'dev\.\K[0-9]+' || echo "0")
    local_build=$(echo "$local_version" | grep -oP 'dev\.\K[0-9]+' || echo "0")
    
    if [[ "$local_build" -ge "$remote_build" ]]; then
      info "master is already up to date (build $local_build)"
      return 0
    fi
    
    info "new master version available (build $local_build → $remote_build)"
    info "removing old master..."
    
    # Remember if master was active
    local was_active=false
    local current_ver
    current_ver="$(current 2>/dev/null || echo "")"
    [[ "$current_ver" == "master" ]] && was_active=true
    
    rm -rf "$dir"
    
    # Continue with normal installation flow
    # After installation, we'll re-activate if needed
  elif [[ -d "$dir" ]]; then
    info "Zig $version already installed"
    return 0
  fi

  # Check if version exists
  local version_exists=$(zig_meta | jq -e "has(\"$version\")" 2>/dev/null)
  
  if [[ "$version_exists" != "true" ]]; then
    die "version '$version' not found. Use 'zix list-remote' to see available versions"
  fi

  local tarball shasum
  tarball="$(zig_field "$version" tarball)"
  shasum="$(zig_field "$version" shasum)"

  if [[ -z "$tarball" ]]; then
    # Show available platforms for this version
    local available_platforms
    available_platforms=$(zig_meta | jq -r ".\"$version\" | keys[]" 2>/dev/null | grep -v "^date$\|^version$\|^docs$\|^stdDocs$\|^src$\|^bootstrap$" | head -10)
    warn "no download available for platform: $PLATFORM"
    if [[ -n "$available_platforms" ]]; then
      warn "available platforms for $version:"
      echo "$available_platforms" | while read -r p; do
        echo "  - $p" >&2
      done
    fi
    die "platform '$PLATFORM' not supported for version '$version'"
  fi

  local mirror url file
  mirror="$(pick_mirror)"
  
  # Extract the full URL from tarball field
  url="$tarball"
  file="$CACHE_DIR/$(basename "$tarball")"

  info "downloading Zig $version for $PLATFORM using $DOWNLOADER..."
  if ! download_file "$url" "$file.tmp"; then
    rm -f "$file.tmp"
    die "download failed"
  fi
  mv "$file.tmp" "$file"

  if [[ -n "$shasum" ]]; then
    info "verifying checksum..."
    if ! echo "$shasum  $file" | sha256sum -c - >/dev/null 2>&1; then
      rm -f "$file"
      die "checksum verification failed"
    fi
  else
    warn "no checksum available, skipping verification"
  fi

  info "extracting..."
  local tmp_dir="$(mktemp -d)"
  trap 'rm -rf "$tmp_dir"' EXIT INT TERM

  # Handle both .tar.xz and .zip files
  if [[ "$file" == *.zip ]]; then
    if ! command -v unzip >/dev/null; then
      rm -rf "$tmp_dir"
      die "unzip not found - install it to extract Windows builds"
    fi
    if ! unzip -q "$file" -d "$tmp_dir" 2>/dev/null; then
      rm -rf "$tmp_dir"
      die "extraction failed"
    fi
  else
    if ! tar -xJf "$file" -C "$tmp_dir" 2>/dev/null; then
      rm -rf "$tmp_dir"
      die "extraction failed"
    fi
  fi

  local extracted="$(find "$tmp_dir" -mindepth 1 -maxdepth 1 -type d | head -n1)"
  if [[ -z "$extracted" ]]; then
    rm -rf "$tmp_dir"
    die "no directory found in archive"
  fi

  mv "$extracted" "$dir"
  rm -rf "$tmp_dir"
  trap - EXIT INT TERM
  
  info "installed Zig $version → $dir"
  
  # Re-activate master if it was previously active
  if [[ "$version" == "master" && "${was_active:-false}" == "true" ]]; then
    info "re-activating master..."
    use "master"
  fi
}

use() {
  local version="${1:-}"
  [[ -z "$version" ]] && die "version required (e.g., 'zix use 0.15.2')"

  local dir="$VERSIONS_DIR/$version"
  [[ ! -d "$dir" ]] && die "Zig $version not installed. Run 'zix install $version' first"

  ln -sfn "$dir" "$ACTIVE_LINK"
  ln -sfn "$ACTIVE_LINK/zig" "$ZIG_SYMLINK"

  info "now using Zig $version"
  "$ZIG_SYMLINK" version 2>/dev/null || true
}

list() {
  if [[ ! -d "$VERSIONS_DIR" || -z "$(ls -A "$VERSIONS_DIR" 2>/dev/null)" ]]; then
    info "no versions installed"
    return
  fi

  local current_version="$(current)"
  
  info "installed versions:"
  for v in "$VERSIONS_DIR"/*; do
    local ver="$(basename "$v")"
    if [[ "$ver" == "$current_version" ]]; then
      echo "  * $ver (active)"
    else
      echo "    $ver"
    fi
  done
}

list_remote() {
  info "fetching available versions..."
  local meta="$(zig_meta)"
  
  # Get all versions and process them
  echo "$meta" | jq -r 'to_entries[] | select(.key != "") | "\(.key)\t\(.value.version // "")"' | sort -V | while IFS=$'\t' read -r key ver; do
    if [[ "$key" == "master" && -n "$ver" ]]; then
      echo "master ($ver)"
    else
      echo "$key"
    fi
  done
}

current() {
  if [[ -L "$ACTIVE_LINK" ]]; then
    basename "$(readlink "$ACTIVE_LINK")"
  else
    echo "none"
    return 1
  fi
}

remove() {
  local version="${1:-}"
  [[ -z "$version" ]] && die "version required"

  local dir="$VERSIONS_DIR/$version"
  [[ ! -d "$dir" ]] && die "Zig $version not installed"

  local current_ver="$(current 2>/dev/null || echo "")"
  if [[ "$version" == "$current_ver" ]]; then
    warn "removing currently active version"
    rm -f "$ACTIVE_LINK" "$ZIG_SYMLINK"
  fi

  rm -rf "$dir"
  info "removed Zig $version"
}

# AUTO (.zigversion)
auto() {
  local file version search_dir

  # Start from current directory and search upwards
  search_dir="$(pwd)"
  
  while true; do
    for file in .zig-version .zigversion .zv; do
      if [[ -f "$search_dir/$file" ]]; then
        info "found version file: $search_dir/$file"
        
        version="$(tr -d ' \t\n\r' < "$search_dir/$file")"
        [[ -z "$version" ]] && die "version file is empty"
        
        # Handle comments and get first non-comment line
        version=$(echo "$version" | grep -v '^#' | head -n1)
        [[ -z "$version" ]] && die "no valid version found in file (only comments)"
        
        info "detected version: $version"
        
        # Check if it's a dev version (like 0.16.0-dev.1976+8e091047b)
        if [[ "$version" =~ ^[0-9]+\.[0-9]+\.[0-9]+-dev\.[0-9]+ ]]; then
          version="master"
          info "switching to: $version"
        fi
        
        # Check if version exists in remote index
        local version_exists=$(zig_meta | jq -e "has(\"$version\")" 2>/dev/null)
        
        if [[ "$version_exists" != "true" ]]; then
          warn "version '$version' not found in Zig index"
          info "available versions:"
          list_remote | tail -10
          die "invalid version specified in $search_dir/$file"
        fi
        
        # Check if version is installed
        if [[ ! -d "$VERSIONS_DIR/$version" ]]; then
          info "version $version not installed"
          read -p "Install $version now? [Y/n] " -n 1 -r
          echo
          if [[ $REPLY =~ ^[Yy]$ ]] || [[ -z $REPLY ]]; then
            install "$version"
          else
            die "installation cancelled"
          fi
        else
          info "version $version already installed"
        fi
        
        use "$version"
        return 0
      fi
    done
    
    # Move up one directory
    if [[ "$search_dir" == "/" ]]; then
      break
    fi
    search_dir="$(dirname "$search_dir")"
  done
  
  die "no .zig-version, .zigversion or .zv file found (searched up to root)"
}

# NIGHTLY
nightly() {
  local version="$(zig_meta | jq -r 'to_entries[] | select(.key | test("^[0-9]+\\.[0-9]+\\.[0-9]+-dev")) | .key' | sort -V | tail -n1)"

  [[ -z "$version" || "$version" == "null" ]] && die "no nightly version found"

  info "latest nightly: $version"

  [[ ! -d "$VERSIONS_DIR/$version" ]] && install "$version"
  use "$version"
}

# ENV
env_cmd() {
cat <<EOF
# Add this to your ~/.bashrc or ~/.zshrc:
export ZIG_HOME="$ZIG_HOME"
export PATH="$BIN_DIR:\$PATH"
EOF
}

# DOCTOR
doctor() {
  echo "Configuration:"
  echo "  ZIG_HOME:   $ZIG_HOME"
  echo "  BIN_DIR:    $BIN_DIR"
  echo "  CACHE_DIR:  $CACHE_DIR"
  echo "  Platform:   $PLATFORM"
  echo "  Downloader: $DOWNLOADER"
  echo

  # Active version check
  local active_ver=""
  if [[ -L "$ACTIVE_LINK" ]]; then
    active_ver="$(current 2>/dev/null || echo "")"
  fi
  
  if [[ -n "$active_ver" && "$active_ver" != "none" ]]; then
    echo "Active version: $active_ver"
    if [[ -x "$ACTIVE_LINK/zig" ]]; then
      local zig_ver
      zig_ver="$("$ACTIVE_LINK/zig" version 2>/dev/null || echo "unknown")"
      echo "  Build: $zig_ver"
    fi
  else
    echo "Active version: none"
  fi
  echo

  # Installed versions
  echo "Installed versions:"
  if [[ -d "$VERSIONS_DIR" ]]; then
    local count=0
    local has_versions=false
    
    # Check if directory has any content
    if [[ -n "$(ls -A "$VERSIONS_DIR" 2>/dev/null)" ]]; then
      has_versions=true
      for v in "$VERSIONS_DIR"/*; do
        if [[ ! -d "$v" ]]; then continue; fi
        local ver_name
        ver_name="$(basename "$v")"
        if [[ "$ver_name" == "$active_ver" ]]; then
          echo "  * $ver_name"
        else
          echo "    $ver_name"
        fi
        ((++count))
      done
    fi
  else
    echo "  No versions installed"
  fi
  echo

  # Zig binary check
  echo "Zig binary:"
  echo "  Path: $ZIG_SYMLINK"
  if [[ -L "$ZIG_SYMLINK" ]]; then
    local link_target
    link_target="$(readlink -f "$ZIG_SYMLINK" 2>/dev/null || echo "broken link")"
    echo "  Link: $link_target"
  fi
  
  if [[ -x "$ZIG_SYMLINK" ]]; then
    echo "  ✓ Exists and executable"
    if "$ZIG_SYMLINK" version >/dev/null 2>&1; then
      echo "  ✓ 'zig version' works"
    else
      echo "  ✗ 'zig version' failed"
    fi
  else
    echo "  ✗ Not found or not executable"
  fi
  echo

  # PATH check
  echo "PATH check:"
  case ":$PATH:" in
    *":$BIN_DIR:"*)
      echo "  ✓ $BIN_DIR is in PATH"
      ;;
    *)
      echo "  ✗ $BIN_DIR NOT in PATH"
      echo "     Add to your shell config:"
      echo "     export PATH=\"$BIN_DIR:\$PATH\""
      ;;
  esac
  echo

  # Required dependencies
  echo "Required dependencies:"
  local missing_deps=()
  for dep in jq sha256sum tar; do
    if command -v "$dep" >/dev/null 2>&1; then
      local dep_path
      dep_path="$(command -v "$dep")"
      echo "  + $dep → $dep_path"
    else
      echo "  - $dep"
      missing_deps+=("$dep")
    fi
  done
  
  if [[ ${#missing_deps[@]} -gt 0 ]]; then
    echo
    echo "  ⚠ Missing: ${missing_deps[*]}"
  fi
  echo
  
  # Download tools
  echo "Download tools:"
  local has_downloader=false
  for tool in aria2c curl wget; do
    if command -v "$tool" >/dev/null 2>&1; then
      has_downloader=true
      local tool_path
      tool_path="$(command -v "$tool")"
      if [[ "$tool" == "$DOWNLOADER" ]]; then
        echo "  * $tool → $tool_path"
      else
        echo "  + $tool → $tool_path"
      fi
    else
      echo "  - $tool"
    fi
  done
  
  if [[ "$has_downloader" == false ]]; then
    echo
    echo "  ✗ No download tool available"
    echo "     Install one: aria2, curl, or wget"
  fi
  echo

  # Cache status
  echo "Cache status:"
  if [[ -f "$INDEX_CACHE" ]]; then
    local cache_age cache_age_hours cache_age_mins
    cache_age=$(( $(now) - $(cat "$INDEX_TS" 2>/dev/null || echo 0) ))
    cache_age_hours=$(( cache_age / 3600 ))
    cache_age_mins=$(( (cache_age % 3600) / 60 ))
    
    if (( cache_age < CACHE_TTL )); then
      echo "  ✓ Index: valid (${cache_age_hours}h ${cache_age_mins}m old, TTL: $((CACHE_TTL / 3600))h)"
    else
      echo "  ⚠ Index: stale (${cache_age_hours}h ${cache_age_mins}m old, TTL: $((CACHE_TTL / 3600))h)"
    fi
  else
    echo "  - Index: not cached"
  fi
  
  if [[ -d "$CACHE_DIR" ]]; then
    local cache_size cache_files
    cache_size=$(du -sh "$CACHE_DIR" 2>/dev/null | cut -f1)
    cache_files=$(find "$CACHE_DIR" -type f 2>/dev/null | wc -l)
    echo "  Size: $cache_size ($cache_files files)"
  fi
  echo
  
  # System info
  echo "System info:"
  echo "  OS: $OS"
  echo "  Arch: $ARCH"
  echo "  Kernel: $(uname -r)"
  echo "  Shell: ${SHELL##*/}"
  
  if [[ -f "$SELF_PATH" ]]; then
    echo "  zix: $SELF_PATH"
  fi
}

# COMPLETIONS
completion_install() {
  local bash_dir="$HOME/.bash_completion.d"
  local zsh_dir="$HOME/.config/zsh/site-functions"
  local fish_dir="$HOME/.config/fish/completions"

  mkdir -p "$bash_dir" "$zsh_dir" "$fish_dir"

cat > "$bash_dir/zix" <<'EOF'
_zix() {
  local cur="${COMP_WORDS[COMP_CWORD]}"
  local prev="${COMP_WORDS[COMP_CWORD-1]}"
  local cmds="install use switch list list-remote current remove auto nightly env doctor clean completion-install update-self"
  
  if [[ $COMP_CWORD -eq 1 ]]; then
    COMPREPLY=($(compgen -W "$cmds" -- "$cur"))
  elif [[ $COMP_CWORD -eq 2 ]]; then
    case "$prev" in
      install)
        # Show remote versions from cached index
        local versions
        if [[ -f "$HOME/.zig/cache/index.json" ]]; then
          versions=$(jq -r 'keys[]' "$HOME/.zig/cache/index.json" 2>/dev/null | sort -V)
          COMPREPLY=($(compgen -W "$versions" -- "$cur"))
        fi
        ;;
      use|remove)
        # Show installed versions
        local versions
        if [[ -d "$HOME/.zig/versions" ]]; then
          versions=$(ls -1 "$HOME/.zig/versions" 2>/dev/null)
          COMPREPLY=($(compgen -W "$versions" -- "$cur"))
        fi
        ;;
    esac
  fi
}
complete -F _zix zix
EOF

cat > "$zsh_dir/_zix" <<'EOF'
#compdef zix
_zix() {
  local -a commands
  commands=(
    'install:install a Zig version'
    'use:switch to a Zig version'
    'switch:switch to a Zig version'
    'list:list installed versions'
    'list-remote:list available versions'
    'current:show current version'
    'remove:remove a version'
    'auto:use version from .zigversion'
    'nightly:install and use latest nightly'
    'env:show environment setup'
    'doctor:check installation'
    'clean:clear download cache'
    'completion-install:install shell completions'
    'update-self:update zix'
  )
  
  case $CURRENT in
    2)
      _describe 'command' commands
      ;;
    3)
      case ${words[2]} in
        install)
          local -a versions
          if [[ -f "$HOME/.zig/cache/index.json" ]]; then
            versions=(${(f)"$(jq -r 'keys[]' "$HOME/.zig/cache/index.json" 2>/dev/null | sort -V)"})
            _describe 'remote version' versions
          fi
          ;;
        use|remove)
          local -a versions
          if [[ -d "$HOME/.zig/versions" ]]; then
            versions=(${(f)"$(ls -1 "$HOME/.zig/versions" 2>/dev/null)"})
            _describe 'installed version' versions
          fi
          ;;
      esac
      ;;
  esac
}
_zix
EOF

cat > "$fish_dir/zix.fish" <<'EOF'
complete -c zix -f
complete -c zix -n "__fish_use_subcommand" -a install -d "Install a Zig version"
complete -c zix -n "__fish_use_subcommand" -a use -d "Switch to a Zig version"
complete -c zix -n "__fish_use_subcommand" -a switch -d "Switch to a Zig version"
complete -c zix -n "__fish_use_subcommand" -a list -d "List installed versions"
complete -c zix -n "__fish_use_subcommand" -a list-remote -d "List available versions"
complete -c zix -n "__fish_use_subcommand" -a current -d "Show current version"
complete -c zix -n "__fish_use_subcommand" -a remove -d "Remove a version"
complete -c zix -n "__fish_use_subcommand" -a auto -d "Use version from .zigversion"
complete -c zix -n "__fish_use_subcommand" -a nightly -d "Install latest nightly"
complete -c zix -n "__fish_use_subcommand" -a env -d "Show environment setup"
complete -c zix -n "__fish_use_subcommand" -a doctor -d "Check installation"
complete -c zix -n "__fish_use_subcommand" -a clean -d "Clear download cache"
complete -c zix -n "__fish_use_subcommand" -a completion-install -d "Install completions"
complete -c zix -n "__fish_use_subcommand" -a update-self -d "Update zix"

# Complete versions for install command (remote versions)
complete -c zix -n "__fish_seen_subcommand_from install" -f -a "(test -f ~/.zig/cache/index.json && jq -r 'keys[]' ~/.zig/cache/index.json 2>/dev/null | sort -V)"

# Complete versions for use/remove commands (local versions)
complete -c zix -n "__fish_seen_subcommand_from use remove" -f -a "(test -d ~/.zig/versions && ls -1 ~/.zig/versions 2>/dev/null)"
EOF

  info "shell completions installed"
  info "restart your shell or source the completion files"
}

# SELF UPDATE
update_self() {
  local repo_url="https://codeberg.org/erffy/zix/raw/branch/master/zix"
  info "updating zix from $repo_url..."
  
  local tmp="$SELF_PATH.tmp"
  if ! fetch_url "$repo_url" "$tmp" 30; then
    rm -f "$tmp"
    die "update failed"
  fi
  
  chmod +x "$tmp"
  mv "$tmp" "$SELF_PATH"
  info "zix updated successfully"
}

# CLEAN CACHE
clean() {
  info "cleaning cache..."
  rm -rf "$CACHE_DIR"/*
  mkdir -p "$CACHE_DIR"
  info "cache cleaned"
}

# USAGE
usage() {
cat <<EOF
zix - Zig Version Manager

Usage: zix <command> [arguments]

Commands:
  install <version>      Install a specific Zig version
  use <version>          Switch to an installed version
  switch <version>       Switch to an installed version (alias to use)
  list                   List installed versions
  list-remote            List all available versions
  current                Show currently active version
  remove <version>       Remove an installed version
  auto                   Use version from .zig-version file
  nightly                Install and use latest nightly build
  env                    Show environment setup commands
  doctor                 Check installation and configuration
  clean                  Clear download cache
  completion-install     Install shell completions
  update-self            Update zix to latest version

Examples:
  zix install 0.15.2     Install Zig 0.15.2
  zix use 0.15.2         Switch to Zig 0.15.2
  zix nightly            Use latest nightly build
  zix auto               Use version from .zig-version

Environment Variables:
  ZIG_HOME              Installation directory (default: ~/.zig)
  ZIX_BIN_DIR           Binary directory (default: ~/.local/bin)
  ZIX_DOWNLOADER        Force downloader: aria2c, curl, or wget (default: auto-detect)
EOF
}

# MAIN
main() {
  local cmd="${1:-}"
  
  case "$cmd" in
    install)
      [[ -z "${2:-}" ]] && die "version required. Usage: zix install <version>"
      install "$2"
      ;;
    use|switch)
      [[ -z "${2:-}" ]] && die "version required. Usage: zix $1 <version>"
      use "$2"
      ;;
    list) list ;;
    list-remote) list_remote ;;
    current) current ;;
    remove|uninstall)
      [[ -z "${2:-}" ]] && die "version required. Usage: zix remove <version>"
      remove "$2"
      ;;
    auto) auto ;;
    nightly) nightly ;;
    env) env_cmd ;;
    doctor) doctor ;;
    clean) clean ;;
    completion-install) completion_install ;;
    update-self) update_self ;;
    -h|--help|help) usage ;;
    "") usage; exit 1 ;;
    *) die "unknown command: $cmd. Run 'zix --help' for usage" ;;
  esac
}

main "$@"